<!-- Juice Project - Est. 2016 | Last updated 2026 -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="icon" type="image/svg+xml" href="/favicon.svg">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <meta name="created" content="2016-03-14">
  <meta name="author" content="Juice Project">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta property="og:type" content="website">
  <meta property="og:site_name" content="The Juice Box">
  <meta property="og:image" content="https://thejuicebox.live/og-image.png">
  <meta property="og:image:type" content="image/png">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="https://thejuicebox.live/og-image.png">
  <meta property="og:title" content="Network Graph">
  <meta property="og:description" content="Comprehensive directory of Jewish organizations worldwide - tracking structure, people, and connections since 2016.">
  <meta property="og:url" content="https://thejuicebox.live/graph.html">
  <meta name="twitter:title" content="Network Graph">
  <meta name="twitter:description" content="Comprehensive directory of Jewish organizations worldwide - tracking structure, people, and connections since 2016.">
  <title>Network Graph</title>

  <style>
    /* ===== BASE ===== */
    body { font-family: Arial, sans-serif; margin: 0; padding: 0; color: #000; background: #fff; }
    nav { padding: 10px 20px; overflow-x: auto; -webkit-overflow-scrolling: touch; }
    nav ul { list-style: none; margin: 0; padding: 10px 15px; display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; align-items: center; }
    nav ul li { margin: 0; white-space: nowrap; }
    nav a { color: #0000EE !important; text-decoration: none; background: rgba(255,255,255,0.85); padding: 5px 12px; white-space: nowrap; border-radius: 6px; border: 1px solid rgba(0,0,255,0.3); box-shadow: 1px 1px 2px rgba(0,0,0,0.2); font-size: 0.82em; display: inline-block; line-height: 1.4; }
    nav select { padding: 6px 10px; border-radius: 6px; border: 1px solid rgba(0,0,255,0.3); font-size: 0.85em; background: rgba(255,255,255,0.85); }

    /* Glassmorphism */
    .panel, .gp, .sb, .header-panel, .graph-wrap {
      background: rgba(255, 255, 255, 0.15) !important;
      backdrop-filter: blur(12px) !important;
      -webkit-backdrop-filter: blur(12px) !important;
      border: 1px solid rgba(255, 255, 255, 0.25) !important;
      border-radius: 12px !important;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08) !important;
    }
    .gp:hover, .header-panel:hover { box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15) !important; border-color: rgba(255, 255, 255, 0.35) !important; }
    nav a {
      background: rgba(255, 255, 255, 0.2) !important;
      backdrop-filter: blur(8px) !important;
      -webkit-backdrop-filter: blur(8px) !important;
      border: 1px solid rgba(255, 255, 255, 0.3) !important;
      border-radius: 8px !important;
    }
    nav select {
      background: rgba(255, 255, 255, 0.2) !important;
      backdrop-filter: blur(8px) !important;
      -webkit-backdrop-filter: blur(8px) !important;
      border: 1px solid rgba(255, 255, 255, 0.3) !important;
    }

    /* ===== PAGE LAYOUT ===== */
    .main { max-width: 1600px; margin: 0 auto; padding: 15px 20px; }
    .header-panel { background: rgba(255,255,255,0.85); border: 1px solid rgba(0,0,255,0.2); border-radius: 8px; padding: 16px 20px; margin-bottom: 15px; }
    .header-panel h1 { margin: 0 0 4px 0; color: #0056b3; }
    .header-panel .subtitle { color: #555; margin: 0; font-size: 0.95em; }

    /* ===== GRAPH WRAPPER ===== */
    .graph-wrap { position: relative; width: 100%; height: 85vh; min-height: 500px; border-radius: 12px; overflow: hidden; border: 1px solid rgba(0,0,255,0.15); background: #fff; }
    #graph-container { position: absolute; inset: 0; width: 100%; height: 100%; }
    #graph-container canvas { border-radius: 12px; display: block; }

    /* ===== SHARED PANEL ===== */
    .gp { overflow: hidden; transition: box-shadow 0.25s; }
    .gp-h {
      display: flex; align-items: center; justify-content: space-between;
      padding: 6px 10px; cursor: pointer; user-select: none;
      background: rgba(0,86,179,0.06);
      border-bottom: 1px solid rgba(0,0,255,0.08);
      transition: background 0.2s;
    }
    .gp-h:hover { background: rgba(0,86,179,0.12); }
    .gp-h strong, .gp-h h3 { color: #0056b3; font-size: 0.78em; font-weight: 600; margin: 0; }
    .gp-h .chv { color: #0056b3; font-size: 0.6em; transition: transform 0.25s; }
    .gp.shut .gp-b { display: none; }
    .gp.shut .gp-h { border-bottom: none; }
    .gp.shut .chv { transform: rotate(180deg); }

    /* ===== CONTROLS (top-left) ===== */
    .hud-ctrl { position: absolute; top: 10px; left: 10px; z-index: 12; width: 210px; }
    .cb { padding: 7px 10px 9px; }
    .cb label { font-size: 0.73em; color: #333; display: block; margin: 4px 0 1px; font-weight: 500; }
    .cb select { width: 100%; padding: 4px 6px; border-radius: 5px; border: 1px solid rgba(0,0,255,0.16); background: rgba(255,255,255,0.85); color: #333; font-size: 0.77em; outline: none; }
    .cb select:focus { border-color: #0056b3; }
    .cb input[type="range"] { width: 100%; margin: 2px 0; accent-color: #0056b3; }
    .cb .chks { display: flex; gap: 10px; margin: 5px 0 2px; }
    .cb .chks label { display: flex; align-items: center; gap: 3px; font-size: 0.73em; color: #333; cursor: pointer; margin: 0; }
    .cb .chks input[type="checkbox"] { accent-color: #0056b3; }
    .cb .btns { display: flex; gap: 5px; margin-top: 5px; }
    .cb .btns button { flex: 1; padding: 4px 0; border-radius: 5px; border: 1px solid rgba(0,0,255,0.16); background: rgba(0,86,179,0.08); color: #0056b3; font-size: 0.73em; font-weight: 600; cursor: pointer; transition: all 0.2s; }
    .cb .btns button:hover { background: rgba(0,86,179,0.18); }

    /* ===== SEARCH (top-center) ===== */
    .hud-search { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); z-index: 12; display: flex; align-items: center; }
    .hud-search input { padding: 5px 11px; border: 1px solid rgba(0,0,255,0.2); border-radius: 6px 0 0 6px; font-size: 0.77em; width: 200px; outline: none; background: rgba(255,255,255,0.85); backdrop-filter: blur(12px); color: #333; }
    .hud-search input::placeholder { color: #888; }
    .hud-search input:focus { border-color: #0056b3; }
    .hud-search button { padding: 5px 9px; border: 1px solid rgba(0,0,255,0.2); border-left: none; border-radius: 0 6px 6px 0; background: rgba(0,86,179,0.1); color: #0056b3; cursor: pointer; font-size: 0.77em; transition: background 0.2s; }
    .hud-search button:hover { background: rgba(0,86,179,0.2); }
    .hud-search .sc { padding: 0 7px; font-size: 0.71em; color: #0056b3; white-space: nowrap; text-shadow: 0 0 4px rgba(255,255,255,0.9); }

    /* ===== STATS (top-right) ===== */
    .hud-stats { position: absolute; top: 10px; right: 10px; z-index: 12; }
    .sb { padding: 5px 11px; font-size: 0.74em; color: #333; white-space: nowrap; }
    .sb b { color: #0056b3; font-weight: 700; }

    /* ===== CATEGORY LEGEND (bottom-left) ===== */
    .hud-cat { position: absolute; bottom: 10px; left: 10px; z-index: 12; width: 190px; }
    .cat-b { padding: 4px 10px 7px; max-height: 180px; overflow-y: auto; }
    .li { display: flex; align-items: center; gap: 5px; font-size: 0.69em; color: #333; margin: 1px 0; cursor: pointer; padding: 1px 2px; border-radius: 3px; transition: background 0.15s; }
    .li:hover { background: rgba(0,86,179,0.08); }
    .ld { width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0; }

    /* ===== EDGE LEGEND (bottom-right) ===== */
    .hud-edge { position: absolute; bottom: 10px; right: 10px; z-index: 12; width: 172px; }
    .edge-b { padding: 3px 10px 7px; max-height: 210px; overflow-y: auto; }
    .ei { display: flex; align-items: center; gap: 5px; font-size: 0.69em; color: #333; margin: 1.5px 0; }
    .el { width: 15px; height: 3px; border-radius: 2px; flex-shrink: 0; }

    /* ===== SCROLLBAR ===== */
    .cat-b::-webkit-scrollbar, .edge-b::-webkit-scrollbar { width: 4px; }
    .cat-b::-webkit-scrollbar-track, .edge-b::-webkit-scrollbar-track { background: transparent; }
    .cat-b::-webkit-scrollbar-thumb, .edge-b::-webkit-scrollbar-thumb { background: rgba(0,0,255,0.15); border-radius: 2px; }

    /* ===== TOOLTIP ===== */
    #tip {
      position: fixed; background: rgba(255,255,255,0.95); backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      color: #222; padding: 10px 14px; border-radius: 9px;
      border: 1px solid rgba(0,0,255,0.15); font-size: 0.79em;
      pointer-events: none; z-index: 200; max-width: 340px;
      line-height: 1.55; display: none;
      box-shadow: 0 8px 28px rgba(0,0,0,0.12);
    }
    #tip strong { color: #0056b3; }
    #tip .tip-cat { display: inline-block; padding: 1px 6px; border-radius: 3px; font-size: 0.85em; margin-top: 3px; }

    /* ===== LOADING ===== */
    .ld-overlay {
      position: absolute; inset: 0; display: flex; flex-direction: column;
      align-items: center; justify-content: center; gap: 12px;
      background: rgba(255,255,255,0.8); backdrop-filter: blur(4px); z-index: 25; transition: opacity 0.5s;
    }
    .ld-overlay.off { opacity: 0; pointer-events: none; }
    .ld-spinner { width: 38px; height: 38px; border: 3px solid rgba(0,0,255,0.1); border-top-color: #0056b3; border-radius: 50%; animation: spin 0.75s linear infinite; }
    .ld-text { color: #0056b3; font-size: 0.82em; font-weight: 600; }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* ===== RESPONSIVE ===== */
    @media (max-width: 900px) {
      .hud-search input { width: 135px; }
      .hud-ctrl { width: 180px; }
      .hud-cat { width: 160px; }
      .hud-edge { width: 148px; }
    }
    @media (max-width: 600px) {
      .hud-search { display: none; }
      .hud-ctrl { width: 160px; }
      .hud-cat, .hud-edge { width: 135px; }
    }
  </style>
</head>
<body>
  <nav id="navbar"></nav>

  <div class="main">
  <div class="header-panel">
    <h1><i class="fa-solid fa-diagram-project"></i> Network Graph</h1>
    <p class="subtitle">Full database visualization — drag nodes, scroll to zoom, hover for details, click to open.</p>
  </div>

  <div class="graph-wrap">
    <div id="graph-container"><canvas id="canvas"></canvas></div>

    <!-- Loading -->
    <div class="ld-overlay" id="loading">
      <div class="ld-spinner"></div>
      <div class="ld-text" id="ld-text">Loading graph data...</div>
    </div>

    <!-- HUD: Controls -->
    <div class="hud-ctrl">
      <div class="gp" id="ctrl-p">
        <div class="gp-h" id="ctrl-t">
          <h3><i class="fa-solid fa-sliders"></i> Controls</h3>
          <span class="chv"><i class="fa-solid fa-chevron-up"></i></span>
        </div>
        <div class="gp-b cb">
          <label>Country</label>
          <select id="f-country"><option value="">All Countries</option></select>
          <label>Category</label>
          <select id="f-cat"><option value="">All Categories</option></select>
          <label>Node Size</label>
          <input type="range" id="node-scale" min="2" max="20" value="6" />
          <label>Spacing</label>
          <input type="range" id="spacing-range" min="30" max="350" value="100" />
          <div class="chks">
            <label><input type="checkbox" id="show-people" /> People</label>
            <label><input type="checkbox" id="show-labels" checked /> Labels</label>
          </div>
          <div class="btns">
            <button id="btn-reload"><i class="fa-solid fa-rotate"></i> Reload</button>
            <button id="btn-fit"><i class="fa-solid fa-compress"></i> Fit</button>
          </div>
        </div>
      </div>
    </div>

    <!-- HUD: Search -->
    <div class="hud-search">
      <input type="text" id="s-input" placeholder="Search nodes..." />
      <button id="s-btn"><i class="fa-solid fa-search"></i></button>
      <span class="sc" id="s-count"></span>
    </div>

    <!-- HUD: Stats -->
    <div class="hud-stats">
      <div class="sb" id="stats"><b>Loading...</b></div>
    </div>

    <!-- HUD: Category legend -->
    <div class="hud-cat">
      <div class="gp" id="cat-p">
        <div class="gp-h" id="cat-t">
          <strong><i class="fa-solid fa-palette"></i> Categories</strong>
          <span class="chv"><i class="fa-solid fa-chevron-up"></i></span>
        </div>
        <div class="gp-b cat-b" id="cat-b"></div>
      </div>
    </div>

    <!-- HUD: Edge legend -->
    <div class="hud-edge">
      <div class="gp" id="edge-p">
        <div class="gp-h" id="edge-t">
          <strong><i class="fa-solid fa-link"></i> Connections</strong>
          <span class="chv"><i class="fa-solid fa-chevron-up"></i></span>
        </div>
        <div class="gp-b edge-b" id="edge-b"></div>
      </div>
    </div>
  </div>
  </div>

  <!-- Tooltip -->
  <div id="tip"></div>

  <script src="app.js"></script>
  <script>
  /* =================================================================
   *  PURE CANVAS2D FULL DATABASE GRAPH — Zero-overlap deterministic layout
   *  No physics engine. No d3-force. No force-graph library.
   *  Pure math layout + raw Canvas2D rendering = instant + smooth.
   * ================================================================= */
  initPage('jewish');
  setSEO({ title: 'Network Graph - Juice Project', description: 'Interactive network visualization.' });

  // ─── Collapsible panels ──────────────────────────────
  ['ctrl','cat','edge'].forEach(k => {
    document.getElementById(k+'-t').onclick = () => document.getElementById(k+'-p').classList.toggle('shut');
  });

  // ─── Color maps ──────────────────────────────────────
  const CC = {
    'Entertainment & Media':'#e74c3c','Religion & Synagogues':'#9b59b6',
    'Culture & Arts':'#e67e22','Technology':'#2ecc71',
    'Community & Social Organizations':'#3498db','Education & Academia':'#1abc9c',
    'Education':'#1abc9c',
    'Representative & Umbrella Bodies':'#f39c12','Heritage & Memorials':'#8e44ad',
    'Charity & Philanthropy':'#e91e63','Investment & Private Equity':'#00bcd4',
    'Real Estate & Property':'#795548','Sports':'#ff5722',
    'Advocacy & Public Affairs':'#607d8b','Healthcare & Pharmaceuticals':'#4caf50',
    'Banking & Financial Services':'#ff9800','Research & Think Tanks':'#673ab7',
    'Retail & E-Commerce':'#009688','Defense & Security':'#f44336',
    'Food & Beverage':'#8bc34a','Conglomerates & Holding Companies':'#9e9e9e',
    'Government & Diplomacy':'#3f51b5','Fashion & Consumer Goods':'#ff4081',
    'Manufacturing & Industry':'#757575','Law Firms':'#455a64',
    'Notable Individuals':'#ffc107','Transportation':'#00acc1',
    'Advertising & PR':'#d81b60','Telecommunications':'#7c4dff',
    'Utilities & Energy':'#66bb6a','People':'#ffab40','Controversy':'#d32f2f'
  };
  const DC='#546e7a', PC='#ffab40';
  const EC = {
    'financial':'#ff9800','shared-person':'#9c27b0','political':'#f44336',
    'organizational':'#2196f3','ideological':'#4caf50','historical':'#795548',
    'legal':'#607d8b','related':'#78909c','partnership':'#00bcd4',
    'subsidiary':'#ff5722','funding':'#ffc107','membership':'#3f51b5',
    'affiliation':'#e91e63','leadership':'#8e44ad','collaboration':'#1abc9c',
    'person-affiliation':'#ffab40','industry peer':'#78909c',
    'affiliate':'#42a5f5','communal partner':'#4db6ac',
    'heritage partner':'#ab47bc','funder':'#ffa726',
    'community institution':'#66bb6a','religious partner':'#ce93d8',
    'umbrella body':'#5c6bc0','member':'#26a69a',
    'museum peer':'#7e57c2','cultural partner':'#ec407a',
    'regional connection':'#8d6e63','educational partner':'#29b6f6',
    'government partner':'#ef5350','sports affiliate':'#ff7043',
    'operating body':'#26c6da','governing body':'#d4e157',
    'preservation partner':'#9ccc65','support':'#7986cb',
    'diplomatic partner':'#f06292','historical support':'#a1887f',
    'parent organization':'#4fc3f7','research partner':'#ba68c8',
    'educational':'#1abc9c','lobbying':'#607d8b',
    'advocacy peer':'#607d8b','pro-Israel peer':'#5c6bc0',
    'super PAC':'#f44336','affiliated charity':'#e91e63',
    'lobbying target':'#3f51b5','congressional ally':'#3f51b5',
    'major donor':'#ff9800','diplomatic bridge':'#f06292',
    'pro-Israel ecosystem':'#4caf50','think tank engagement':'#673ab7',
    'social connection':'#9c27b0','academic donation':'#1abc9c',
    'alleged intelligence connection':'#f44336',
    'science connection':'#2ecc71','property':'#795548',
    'investigation':'#607d8b','social':'#9c27b0'
  };
  const DEC='#90a4ae';

  // ─── State ───────────────────────────────────────────
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const container = document.getElementById('graph-container');
  const tipEl = document.getElementById('tip');

  let nodes = [], links = [], nodeMap = {};
  let hoveredNode = null, hoveredLink = null;
  let searchMatches = new Set();
  let neighborMap = {}, neighborSet = new Set();
  let mouseX = 0, mouseY = 0;
  let nodeScale = 6;

  // Camera
  let camX = 0, camY = 0, camZ = 1;
  let isDragging = false, wasDragged = false;
  let dragNode = null;
  let dragStartX = 0, dragStartY = 0, dragCamX = 0, dragCamY = 0;
  let needsRedraw = true;

  // ─── Spatial index ──────────────────────────────────
  let gridCellSize = 80;
  let spatialGrid = {};

  function buildSpatialGrid() {
    spatialGrid = {};
    gridCellSize = Math.max(30, 60 / Math.max(camZ, 0.05));
    for (const n of nodes) {
      const gx = Math.floor(n.x / gridCellSize);
      const gy = Math.floor(n.y / gridCellSize);
      const key = gx + ',' + gy;
      if (!spatialGrid[key]) spatialGrid[key] = [];
      spatialGrid[key].push(n);
    }
  }

  function findNodeAt(wx, wy) {
    const gx = Math.floor(wx / gridCellSize);
    const gy = Math.floor(wy / gridCellSize);
    let best = null, bestDist = Infinity;
    for (let dx = -1; dx <= 1; dx++) {
      for (let dy = -1; dy <= 1; dy++) {
        const cell = spatialGrid[(gx+dx)+','+(gy+dy)];
        if (!cell) continue;
        for (const n of cell) {
          const d = (n.x - wx) * (n.x - wx) + (n.y - wy) * (n.y - wy);
          const r = (n._size || 6) + 5 / camZ;
          if (d < r * r && d < bestDist) { bestDist = d; best = n; }
        }
      }
    }
    return best;
  }

  function findLinkAt(wx, wy) {
    const threshold = 5 / camZ;
    const th2 = threshold * threshold;
    for (const l of links) {
      const s = nodeMap[l.source], t = nodeMap[l.target];
      if (!s || !t) continue;
      const dx = t.x - s.x, dy = t.y - s.y;
      const len2 = dx * dx + dy * dy;
      if (len2 === 0) continue;
      let p = ((wx - s.x) * dx + (wy - s.y) * dy) / len2;
      p = Math.max(0, Math.min(1, p));
      const px = s.x + p * dx, py = s.y + p * dy;
      const dist2 = (wx - px) * (wx - px) + (wy - py) * (wy - py);
      if (dist2 < th2) return l;
    }
    return null;
  }

  function screenToWorld(sx, sy) {
    const rect = canvas.getBoundingClientRect();
    return {
      x: (sx - rect.left - rect.width / 2) / camZ + camX,
      y: (sy - rect.top - rect.height / 2) / camZ + camY
    };
  }

  // ═══════════════════════════════════════════════════════
  //  DETERMINISTIC CATEGORY RADIAL LAYOUT
  //  Entries grouped by category on proportional ring sectors
  //  People on outer ring. O(n), zero overlap.
  // ═══════════════════════════════════════════════════════
  function computeLayout(data, spacing) {
    const sf = (spacing || 100) / 100;
    const entries = data.nodes.filter(n => n.nodeType !== 'person');
    const people = data.nodes.filter(n => n.nodeType === 'person');

    // Group entries by category
    const catGroups = {};
    entries.forEach(n => {
      const cat = n.category || 'Other';
      if (!catGroups[cat]) catGroups[cat] = [];
      catGroups[cat].push(n);
    });
    const categories = Object.keys(catGroups).sort((a, b) => catGroups[b].length - catGroups[a].length);

    // Build person→entry mapping
    const p2e = {};
    data.links.forEach(l => {
      if (l.type === 'person-affiliation') {
        const s = (typeof l.source === 'string') ? l.source : (l.source.id || l.source);
        const t = (typeof l.target === 'string') ? l.target : (l.target.id || l.target);
        const pid = String(s).startsWith('person-') ? s : t;
        const eid = String(s).startsWith('person-') ? t : s;
        if (!p2e[pid]) p2e[pid] = [];
        p2e[pid].push(eid);
      }
    });

    // Ring radius based on entry count
    const nE = Math.max(entries.length, 1);
    const entrySpacing = 18 * sf;
    const R_entry = Math.max(400 * sf, nE * entrySpacing / (2 * Math.PI));

    // Place entries on ring, grouped by category
    let angleOffset = -Math.PI / 2;
    const entryAngles = {};

    categories.forEach(cat => {
      const group = catGroups[cat];
      const proportion = group.length / nE;
      const sectorSize = proportion * 2 * Math.PI;

      group.sort((a, b) => (b._degree || 0) - (a._degree || 0));
      group.forEach((n, i) => {
        const a = angleOffset + (sectorSize * (i + 0.5)) / group.length;
        n.x = R_entry * Math.cos(a);
        n.y = R_entry * Math.sin(a);
        entryAngles[n.id] = a;
      });
      angleOffset += sectorSize;
    });

    // Group people near their parent entries
    const entryPeopleMap = {};
    const placed = new Set();

    people.forEach(p => {
      const parentEntries = p2e[p.id] || [];
      for (const eid of parentEntries) {
        if (entryAngles[eid] !== undefined) {
          if (!entryPeopleMap[eid]) entryPeopleMap[eid] = [];
          entryPeopleMap[eid].push(p);
          placed.add(p.id);
          break;
        }
      }
    });

    const unplaced = people.filter(p => !placed.has(p.id));

    // Entry-specific people: arc near parent
    const wedge = (2 * Math.PI) / nE;
    const R_people = Math.max(R_entry * 1.5, people.length * 14 / (2 * Math.PI)) * sf;

    Object.entries(entryPeopleMap).forEach(([eid, ppl]) => {
      const baseAngle = entryAngles[eid] || 0;
      const count = ppl.length;
      const maxArc = wedge * 0.7;
      const arc = Math.min(maxArc, count * 0.05);
      const r = (R_entry + R_people) * 0.5 * sf;

      ppl.forEach((p, i) => {
        const offset = count > 1 ? (arc * i / (count - 1)) - arc / 2 : 0;
        const a = baseAngle + offset;
        p.x = r * Math.cos(a);
        p.y = r * Math.sin(a);
      });
    });

    // Unplaced people on full outer ring
    if (unplaced.length > 0) {
      const nUP = unplaced.length;
      const R_outer = R_people * 1.1;
      unplaced.forEach((p, i) => {
        const a = (2 * Math.PI * i) / nUP - Math.PI / 2;
        p.x = R_outer * Math.cos(a);
        p.y = R_outer * Math.sin(a);
      });
    }
  }

  // ═══════════════════════════════════════════════════════
  //  CANVAS2D RENDERING
  // ═══════════════════════════════════════════════════════
  function resizeCanvas() {
    const rect = container.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    canvas.style.width = rect.width + 'px';
    canvas.style.height = rect.height + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    needsRedraw = true;
  }

  function draw() {
    if (!needsRedraw) { requestAnimationFrame(draw); return; }
    needsRedraw = false;

    const W = canvas.clientWidth, H = canvas.clientHeight;
    ctx.clearRect(0, 0, W, H);
    ctx.save();
    ctx.translate(W / 2, H / 2);
    ctx.scale(camZ, camZ);
    ctx.translate(-camX, -camY);

    const showLabels = document.getElementById('show-labels').checked;
    const dimAlpha = 0.04;
    const hasHover = !!hoveredNode;
    const hasSearch = searchMatches.size > 0;

    // ── Links ──
    for (const l of links) {
      const s = nodeMap[l.source], t = nodeMap[l.target];
      if (!s || !t) continue;

      let alpha = 0.25, width = 0.5;
      if (hasHover) {
        if (l.source === hoveredNode.id || l.target === hoveredNode.id) {
          alpha = 0.9; width = 2 / camZ;
        } else { alpha = dimAlpha; width = 0.3 / camZ; }
      } else if (hasSearch) {
        if (searchMatches.has(l.source) || searchMatches.has(l.target)) {
          alpha = 0.7; width = 1.2 / camZ;
        } else { alpha = dimAlpha; width = 0.3 / camZ; }
      }

      ctx.globalAlpha = alpha;
      ctx.strokeStyle = l._color || DEC;
      ctx.lineWidth = width;
      ctx.beginPath();
      ctx.moveTo(s.x, s.y);
      ctx.lineTo(t.x, t.y);
      if (l.type === 'person-affiliation') {
        ctx.setLineDash([4 / camZ, 3 / camZ]);
      } else {
        ctx.setLineDash([]);
      }
      ctx.stroke();
      ctx.setLineDash([]);
    }

    // ── Nodes ──
    for (const n of nodes) {
      const isHovered = n === hoveredNode;
      const isNeighbor = hasHover && neighborSet.has(n.id);
      const dimByHover = hasHover && !isHovered && !isNeighbor;
      const dimBySearch = hasSearch && !n._found;
      const shouldDim = dimByHover || dimBySearch;

      ctx.globalAlpha = shouldDim ? dimAlpha : 1;

      const size = n._size;

      ctx.beginPath();
      if (n.nodeType === 'person') {
        ctx.moveTo(n.x, n.y - size);
        ctx.lineTo(n.x + size * 0.75, n.y);
        ctx.lineTo(n.x, n.y + size);
        ctx.lineTo(n.x - size * 0.75, n.y);
        ctx.closePath();
      } else {
        ctx.arc(n.x, n.y, size, 0, Math.PI * 2);
      }
      ctx.fillStyle = n._color;
      ctx.fill();

      if (isHovered) {
        ctx.strokeStyle = '#0056b3';
        ctx.lineWidth = 2.5 / camZ;
        ctx.stroke();
      } else if (n._found) {
        ctx.strokeStyle = '#ffeb3b';
        ctx.lineWidth = 2 / camZ;
        ctx.stroke();
      } else if (!shouldDim) {
        ctx.strokeStyle = 'rgba(0,0,0,0.1)';
        ctx.lineWidth = 0.4 / camZ;
        ctx.stroke();
      }

      if (!shouldDim && showLabels) {
        const shouldShowLabel = isHovered || isNeighbor || n._found ||
          ((n._degree || 0) > 12 && camZ > 0.5) ||
          ((n._degree || 0) > 6 && camZ > 1.0) ||
          ((n._degree || 0) > 2 && camZ > 2.0) ||
          camZ > 3.5;

        if (shouldShowLabel) {
          const fontSize = Math.max(3, (isHovered ? 12 : 10) / camZ);
          ctx.font = (isHovered ? 'bold ' : '') + fontSize + 'px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'top';
          const label = n.name || '';
          const tw = ctx.measureText(label).width;
          const ty = n.y + size + 2 / camZ;
          const pad = 1.5 / camZ;

          ctx.globalAlpha = 0.88;
          ctx.fillStyle = '#fff';
          ctx.fillRect(n.x - tw / 2 - pad, ty - pad, tw + pad * 2, fontSize + pad * 2);
          ctx.globalAlpha = shouldDim ? dimAlpha : 1;
          ctx.fillStyle = isHovered ? '#0056b3' : '#333';
          ctx.fillText(label, n.x, ty);
        }
      }
    }

    ctx.restore();
    ctx.globalAlpha = 1;
    requestAnimationFrame(draw);
  }

  // ═══════════════════════════════════════════════════════
  //  EVENT HANDLERS
  // ═══════════════════════════════════════════════════════
  document.addEventListener('mousemove', e => {
    mouseX = e.clientX; mouseY = e.clientY;
    if (tipEl.style.display === 'block') {
      tipEl.style.left = Math.min(mouseX + 15, window.innerWidth - 360) + 'px';
      tipEl.style.top = Math.min(mouseY - 10, window.innerHeight - 120) + 'px';
    }
  });

  canvas.addEventListener('mousemove', e => {
    const w = screenToWorld(e.clientX, e.clientY);

    if (isDragging && dragNode) {
      dragNode.x = w.x; dragNode.y = w.y;
      wasDragged = true;
      buildSpatialGrid();
      needsRedraw = true;
      return;
    }

    if (isDragging) {
      const dx = e.clientX - dragStartX, dy = e.clientY - dragStartY;
      if (Math.abs(dx) > 3 || Math.abs(dy) > 3) wasDragged = true;
      camX = dragCamX - dx / camZ;
      camY = dragCamY - dy / camZ;
      needsRedraw = true;
      return;
    }

    const node = findNodeAt(w.x, w.y);
    if (node !== hoveredNode) {
      hoveredNode = node;
      hoveredLink = null;
      neighborSet.clear();
      if (node) {
        canvas.style.cursor = 'pointer';
        neighborSet.add(node.id);
        const nb = neighborMap[node.id];
        if (nb) nb.forEach(id => neighborSet.add(id));
        showNodeTooltip(node);
      } else {
        const link = findLinkAt(w.x, w.y);
        if (link) {
          hoveredLink = link;
          canvas.style.cursor = 'pointer';
          showLinkTooltip(link);
        } else {
          canvas.style.cursor = 'grab';
          tipEl.style.display = 'none';
        }
      }
      needsRedraw = true;
    }
  });

  canvas.addEventListener('mousedown', e => {
    if (e.button !== 0) return;
    const w = screenToWorld(e.clientX, e.clientY);
    const node = findNodeAt(w.x, w.y);
    isDragging = true;
    wasDragged = false;
    if (node) {
      dragNode = node;
    } else {
      dragNode = null;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      dragCamX = camX;
      dragCamY = camY;
      canvas.style.cursor = 'grabbing';
    }
    e.preventDefault();
  });

  canvas.addEventListener('mouseup', e => {
    if (!isDragging) return;
    const clickedOnNode = dragNode;
    const dragged = wasDragged;

    if (dragNode) { buildSpatialGrid(); }
    isDragging = false;
    dragNode = null;
    canvas.style.cursor = 'grab';
    needsRedraw = true;

    if (!dragged) {
      if (clickedOnNode) {
        handleNodeClick(clickedOnNode);
        return;
      }
      const w = screenToWorld(e.clientX, e.clientY);
      const link = findLinkAt(w.x, w.y);
      if (link) {
        handleLinkClick(link);
        return;
      }
      // Background click — clear search
      searchMatches.clear();
      nodes.forEach(n => { n._found = false; });
      document.getElementById('s-count').textContent = '';
      document.getElementById('s-input').value = '';
      needsRedraw = true;
    }
  });

  canvas.addEventListener('wheel', e => {
    e.preventDefault();
    const zoomFactor = e.deltaY < 0 ? 1.12 : 0.89;
    const newZ = Math.max(0.02, Math.min(15, camZ * zoomFactor));
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left - rect.width / 2;
    const my = e.clientY - rect.top - rect.height / 2;
    camX += mx / camZ - mx / newZ;
    camY += my / camZ - my / newZ;
    camZ = newZ;
    buildSpatialGrid();
    needsRedraw = true;
  }, { passive: false });

  // Touch support
  let lastTouchDist = 0;
  canvas.addEventListener('touchstart', e => {
    if (e.touches.length === 1) {
      const t = e.touches[0];
      isDragging = true; wasDragged = false;
      dragStartX = t.clientX; dragStartY = t.clientY;
      dragCamX = camX; dragCamY = camY;
      const w = screenToWorld(t.clientX, t.clientY);
      dragNode = findNodeAt(w.x, w.y) || null;
    } else if (e.touches.length === 2) {
      const dx = e.touches[0].clientX - e.touches[1].clientX;
      const dy = e.touches[0].clientY - e.touches[1].clientY;
      lastTouchDist = Math.sqrt(dx * dx + dy * dy);
    }
    e.preventDefault();
  }, { passive: false });

  canvas.addEventListener('touchmove', e => {
    if (e.touches.length === 1 && isDragging) {
      const t = e.touches[0];
      if (dragNode) {
        const w = screenToWorld(t.clientX, t.clientY);
        dragNode.x = w.x; dragNode.y = w.y;
        wasDragged = true;
        buildSpatialGrid();
      } else {
        const dx = t.clientX - dragStartX, dy = t.clientY - dragStartY;
        if (Math.abs(dx) > 3 || Math.abs(dy) > 3) wasDragged = true;
        camX = dragCamX - dx / camZ;
        camY = dragCamY - dy / camZ;
      }
      needsRedraw = true;
    } else if (e.touches.length === 2) {
      const dx = e.touches[0].clientX - e.touches[1].clientX;
      const dy = e.touches[0].clientY - e.touches[1].clientY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (lastTouchDist > 0) {
        camZ = Math.max(0.02, Math.min(15, camZ * (dist / lastTouchDist)));
        buildSpatialGrid();
        needsRedraw = true;
      }
      lastTouchDist = dist;
      wasDragged = true;
    }
    e.preventDefault();
  }, { passive: false });

  canvas.addEventListener('touchend', e => {
    if (e.touches.length === 0) {
      if (!wasDragged && dragNode) handleNodeClick(dragNode);
      isDragging = false; dragNode = null; lastTouchDist = 0;
      needsRedraw = true;
    }
  });

  document.querySelector('.graph-wrap').addEventListener('mouseleave', () => {
    tipEl.style.display = 'none';
    hoveredNode = null; hoveredLink = null;
    neighborSet.clear();
    needsRedraw = true;
  });

  // ─── Tooltip helpers ─────────────────────────────────
  function showNodeTooltip(node) {
    let html;
    if (node.nodeType === 'person') {
      html = '<strong><i class="fa-solid fa-user"></i> ' + node.name + '</strong><br/>'
        + '<i class="fa-solid fa-briefcase"></i> ' + (node.role || 'Individual') + '<br/>'
        + '<i class="fa-solid fa-globe"></i> ' + (node.country || '')
        + '<br/><span style="color:#666;font-size:0.85em">' + (node._degree || 0) + ' connections</span>';
    } else {
      html = '<strong>' + node.name + '</strong><br/>'
        + '<i class="fa-solid fa-building"></i> ' + (node.type || '') + '<br/>'
        + '<i class="fa-solid fa-globe"></i> ' + (node.country || '') + '<br/>'
        + '<span class="tip-cat" style="background:' + (CC[node.category] || DC) + '30;color:' + (CC[node.category] || DC) + '">' + (node.category || '') + '</span>'
        + '<br/><span style="color:#666;font-size:0.85em">' + (node._degree || 0) + ' connections</span>';
    }
    tipEl.innerHTML = html;
    tipEl.style.display = 'block';
    tipEl.style.left = Math.min(mouseX + 15, window.innerWidth - 360) + 'px';
    tipEl.style.top = Math.min(mouseY - 10, window.innerHeight - 120) + 'px';
  }

  function showLinkTooltip(link) {
    tipEl.innerHTML = '<strong>' + (link.type || 'related') + '</strong>'
      + (link.description ? '<br/>' + link.description : '')
      + '<br/><span style="color:#888;font-size:0.85em">Click to explore</span>';
    tipEl.style.display = 'block';
    tipEl.style.left = Math.min(mouseX + 15, window.innerWidth - 360) + 'px';
    tipEl.style.top = Math.min(mouseY - 10, window.innerHeight - 120) + 'px';
  }

  // ─── Click handlers ──────────────────────────────────
  function handleNodeClick(node) {
    if (!node) return;
    if (node.nodeType === 'person') {
      window.location.href = 'person.html?id=' + encodeURIComponent(node.personId || node.id);
    } else {
      window.location.href = 'entry.html?religion=jewish&id=' + encodeURIComponent(node.id);
    }
  }

  function handleLinkClick(link) {
    if (!link) return;
    const src = nodeMap[link.source], tgt = nodeMap[link.target];
    if (link.type === 'person-affiliation') {
      const person = (src && src.nodeType === 'person') ? src : (tgt && tgt.nodeType === 'person') ? tgt : null;
      if (person) { window.location.href = 'person.html?id=' + encodeURIComponent(person.personId || person.id); return; }
    }
    const entry = tgt && tgt.nodeType === 'entry' ? tgt : src && src.nodeType === 'entry' ? src : null;
    if (entry) { window.location.href = 'entry.html?religion=jewish&id=' + encodeURIComponent(entry.id); }
  }

  // ─── Fit view ────────────────────────────────────────
  function fitView(subset) {
    const target = subset || nodes;
    if (target.length === 0) return;
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    target.forEach(n => {
      if (n.x < minX) minX = n.x; if (n.x > maxX) maxX = n.x;
      if (n.y < minY) minY = n.y; if (n.y > maxY) maxY = n.y;
    });
    const W = canvas.clientWidth, H = canvas.clientHeight;
    const dw = (maxX - minX) || 100, dh = (maxY - minY) || 100;
    const pad = 80;
    camZ = Math.min((W - pad * 2) / dw, (H - pad * 2) / dh, 4);
    camX = (minX + maxX) / 2;
    camY = (minY + maxY) / 2;
    buildSpatialGrid();
    needsRedraw = true;
  }

  // ─── Build and render graph ──────────────────────────
  function buildGraph(data) {
    const spacing = +document.getElementById('spacing-range').value;

    // Compute degrees
    const degreeMap = {};
    data.nodes.forEach(n => { degreeMap[n.id] = 0; });
    data.links.forEach(l => {
      degreeMap[l.source] = (degreeMap[l.source] || 0) + 1;
      degreeMap[l.target] = (degreeMap[l.target] || 0) + 1;
    });

    // Build neighbor map
    neighborMap = {};
    data.nodes.forEach(n => { neighborMap[n.id] = new Set(); });
    data.links.forEach(l => {
      if (neighborMap[l.source]) neighborMap[l.source].add(l.target);
      if (neighborMap[l.target]) neighborMap[l.target].add(l.source);
    });

    // Assign properties
    const ns = nodeScale;
    data.nodes.forEach(n => {
      n._degree = degreeMap[n.id] || 0;
      n._color = n.nodeType === 'person' ? PC : (CC[n.category] || DC);
      n._found = false;
      if (n.nodeType === 'person') {
        n._size = Math.max(ns * 0.4, ns * 0.4 + n._degree * (ns * 0.05));
      } else {
        n._size = Math.max(ns * 0.6, ns * 0.6 + n._degree * (ns * 0.07));
      }
    });
    data.links.forEach(l => { l._color = EC[l.type] || DEC; });

    computeLayout(data, spacing);

    nodes = data.nodes;
    links = data.links;
    nodeMap = {};
    nodes.forEach(n => { nodeMap[n.id] = n; });
    buildSpatialGrid();

    // Stats
    const entryCount = nodes.filter(n => n.nodeType !== 'person').length;
    const peopleCount = nodes.filter(n => n.nodeType === 'person').length;
    document.getElementById('stats').innerHTML =
      '<b>' + entryCount + '</b> entries &middot; <b>' + peopleCount + '</b> people &middot; <b>' + links.length + '</b> links';

    // Category legend
    const cats = [...new Set(nodes.map(n => n.category))].filter(Boolean).sort();
    const catB = document.getElementById('cat-b');
    catB.innerHTML = '';
    cats.forEach(c => {
      const r = document.createElement('div'); r.className = 'li';
      const d = document.createElement('div'); d.className = 'ld';
      d.style.background = CC[c] || DC;
      if (c === 'People') { d.style.borderRadius = '2px'; d.style.transform = 'rotate(45deg)'; }
      r.appendChild(d);
      r.appendChild(document.createTextNode(c));
      r.onclick = function() {
        searchMatches.clear();
        nodes.forEach(n => { n._found = n.category === c; if (n._found) searchMatches.add(n.id); });
        document.getElementById('s-count').textContent = searchMatches.size + ' in ' + c;
        document.getElementById('s-input').value = '';
        fitView(nodes.filter(n => n._found));
      };
      catB.appendChild(r);
    });

    // Edge legend
    const eTypes = [...new Set(links.map(l => l.type).filter(Boolean))].sort();
    const edgeB = document.getElementById('edge-b');
    edgeB.innerHTML = '';
    eTypes.forEach(t => {
      const r = document.createElement('div'); r.className = 'ei';
      const l = document.createElement('div'); l.className = 'el';
      l.style.background = EC[t] || DEC;
      r.appendChild(l);
      r.appendChild(document.createTextNode(t));
      edgeB.appendChild(r);
    });

    searchMatches.clear();
    hoveredNode = null; hoveredLink = null;
    neighborSet.clear();

    fitView();
    needsRedraw = true;
    setTimeout(() => { document.getElementById('loading').classList.add('off'); }, 100);
  }

  // ─── Populate dropdowns ──────────────────────────────
  let catOk = 0, cOk = 0;
  function tryLoad() { if (catOk && cOk) loadGraph(); }

  fetch('/api/jewish/categories').then(r=>r.json()).then(d => {
    const s = document.getElementById('f-cat');
    Object.keys(d.categories).sort().forEach(c => {
      const o = document.createElement('option');
      o.value = c; o.textContent = c + ' (' + d.categories[c].count + ')';
      s.appendChild(o);
    });
    catOk = 1; tryLoad();
  });
  fetch('/api/countries').then(r=>r.json()).then(d => {
    const s = document.getElementById('f-country');
    (Array.isArray(d) ? d : d.countries || []).sort().forEach(c => {
      const o = document.createElement('option');
      o.value = c; o.textContent = c;
      s.appendChild(o);
    });
    cOk = 1; tryLoad();
  });

  // ─── Load data ───────────────────────────────────────
  function loadGraph() {
    const country = document.getElementById('f-country').value;
    const cat = document.getElementById('f-cat').value;
    const ppl = document.getElementById('show-people').checked;
    let url = '/api/graph?people=' + (ppl ? '1' : '0');
    if (country) url += '&country=' + encodeURIComponent(country);
    if (cat) url += '&category=' + encodeURIComponent(cat);

    const ld = document.getElementById('loading');
    const lt = document.getElementById('ld-text');
    ld.classList.remove('off');
    lt.textContent = 'Fetching graph data...';
    document.getElementById('stats').innerHTML = '<b>Loading...</b>';

    fetch(url).then(r => r.json()).then(data => {
      lt.textContent = 'Computing layout for ' + data.nodes.length + ' nodes...';
      setTimeout(() => buildGraph(data), 10);
    }).catch(err => {
      console.error('Load error:', err);
      lt.textContent = 'Error loading data.';
    });
  }

  // ─── Controls ────────────────────────────────────────
  document.getElementById('btn-reload').onclick = loadGraph;
  document.getElementById('btn-fit').onclick = () => fitView();
  document.getElementById('show-people').onchange = loadGraph;
  document.getElementById('show-labels').onchange = () => { needsRedraw = true; };
  document.getElementById('f-country').onchange = loadGraph;
  document.getElementById('f-cat').onchange = loadGraph;

  document.getElementById('node-scale').oninput = function() {
    nodeScale = +this.value;
    const ns = nodeScale;
    nodes.forEach(n => {
      if (n.nodeType === 'person') {
        n._size = Math.max(ns * 0.4, ns * 0.4 + n._degree * (ns * 0.05));
      } else {
        n._size = Math.max(ns * 0.6, ns * 0.6 + n._degree * (ns * 0.07));
      }
    });
    needsRedraw = true;
  };

  document.getElementById('spacing-range').oninput = function() {
    if (nodes.length === 0) return;
    computeLayout({ nodes, links }, +this.value);
    buildSpatialGrid();
    needsRedraw = true;
  };

  // ─── Search ──────────────────────────────────────────
  function doSearch() {
    const q = document.getElementById('s-input').value.trim().toLowerCase();
    searchMatches.clear();
    nodes.forEach(n => { n._found = false; });
    if (!q) { document.getElementById('s-count').textContent = ''; needsRedraw = true; return; }
    const matches = nodes.filter(n => (n.name || '').toLowerCase().includes(q));
    matches.forEach(n => { n._found = true; searchMatches.add(n.id); });
    document.getElementById('s-count').textContent = matches.length ? matches.length + ' found' : 'none';
    if (matches.length) fitView(matches);
    needsRedraw = true;
  }
  document.getElementById('s-btn').onclick = doSearch;
  document.getElementById('s-input').onkeydown = function(e) { if (e.key === 'Enter') doSearch(); };
  document.getElementById('s-input').oninput = function() {
    if (!this.value.trim()) {
      searchMatches.clear();
      nodes.forEach(n => { n._found = false; });
      document.getElementById('s-count').textContent = '';
      needsRedraw = true;
    }
  };

  // ─── Init ────────────────────────────────────────────
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);
  requestAnimationFrame(draw);
  </script>
</body>
</html>
